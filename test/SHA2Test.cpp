#include "OpenSSLTest.h"
#include "sha_digest.h"

class SHA2Test : public OpenSSLTest
{
public:
  void SetUp() final;
  void TearDown() final;

protected:
  uint8_t  Data[8*8*1024];
  uint32_t DataLen;
  uint8_t  Hash[512/8];
  uint32_t HashLen;
};

void SHA2Test::SetUp()
{
  memset(Data, sizeof(Data), 0);
  memset(Hash, sizeof(Hash), 0);
  DataLen = 0;
}

void SHA2Test::TearDown()
{}

TEST_F(SHA2Test, abc)
{
  uint8_t test_data[] = {0x61, 0x62, 0x63};
  uint8_t sha224[] = {0x23,0x09,0x7d,0x22,0x34,0x05,0xd8,0x22,0x86,0x42,0xa4,0x77,0xbd,0xa2,0x55,0xb3,0x2a,0xad,0xbc,0xe4,0xbd,0xa0,0xb3,0xf7,0xe3,0x6c,0x9d,0xa7};
  uint8_t sha256[] = {0xba,0x78,0x16,0xbf,0x8f,0x01,0xcf,0xea,0x41,0x41,0x40,0xde,0x5d,0xae,0x22,0x23,0xb0,0x03,0x61,0xa3,0x96,0x17,0x7a,0x9c,0xb4,0x10,0xff,0x61,0xf2,0x00,0x15,0xad};
  uint8_t sha384[] = {0xcb,0x00,0x75,0x3f,0x45,0xa3,0x5e,0x8b,0xb5,0xa0,0x3d,0x69,0x9a,0xc6,0x50,0x07,0x27,0x2c,0x32,0xab,0x0e,0xde,0xd1,0x63,0x1a,0x8b,0x60,0x5a,0x43,0xff,0x5b,0xed,0x80,0x86,0x07,0x2b,0xa1,0xe7,0xcc,0x23,0x58,0xba,0xec,0xa1,0x34,0xc8,0x25,0xa7};
  uint8_t sha512[] = {0xdd,0xaf,0x35,0xa1,0x93,0x61,0x7a,0xba,0xcc,0x41,0x73,0x49,0xae,0x20,0x41,0x31,0x12,0xe6,0xfa,0x4e,0x89,0xa9,0x7e,0xa2,0x0a,0x9e,0xee,0xe6,0x4b,0x55,0xd3,0x9a,0x21,0x92,0x99,0x2a,0x27,0x4f,0xc1,0xa8,0x36,0xba,0x3c,0x23,0xa3,0xfe,0xeb,0xbd,0x45,0x4d,0x44,0x23,0x64,0x3c,0xe8,0x0e,0x2a,0x9a,0xc9,0x4f,0xa5,0x4c,0xa4,0x9f};

  DataLen = sizeof(test_data);
  memcpy(Data, test_data, DataLen);

  printf("Data   : ");
  print_hex(Data, DataLen, false);
  HashLen = digest_message(Data, DataLen, Hash, EVP_sha224());
  EXPECT_EQ(HashLen, 224/8);
  EXPECT_ARRAY_EQ(Hash, sha224, HashLen);
  printf("Hash224: ");
  print_hex(Hash, HashLen, false);

  HashLen = digest_message(Data, DataLen, Hash, EVP_sha256());
  EXPECT_EQ(HashLen, 256/8);
  EXPECT_ARRAY_EQ(Hash, sha256, HashLen);
  printf("Hash256: ");
  print_hex(Hash, HashLen, false);

  HashLen = digest_message(Data, DataLen, Hash, EVP_sha384());
  EXPECT_EQ(HashLen, 384/8);
  EXPECT_ARRAY_EQ(Hash, sha384, HashLen);
  printf("Hash384: ");
  print_hex(Hash, HashLen, false);  

  HashLen = digest_message(Data, DataLen, Hash, EVP_sha512());
  EXPECT_EQ(HashLen, 512/8);
  EXPECT_ARRAY_EQ(Hash, sha512, HashLen);
  printf("Hash512: ");
  print_hex(Hash, HashLen, false);
}


TEST_F(SHA2Test, NULL)
{
  uint8_t sha224[] = {0xd1,0x4a,0x02,0x8c,0x2a,0x3a,0x2b,0xc9,0x47,0x61,0x02,0xbb,0x28,0x82,0x34,0xc4,0x15,0xa2,0xb0,0x1f,0x82,0x8e,0xa6,0x2a,0xc5,0xb3,0xe4,0x2f};
  uint8_t sha256[] = {0xe3,0xb0,0xc4,0x42,0x98,0xfc,0x1c,0x14,0x9a,0xfb,0xf4,0xc8,0x99,0x6f,0xb9,0x24,0x27,0xae,0x41,0xe4,0x64,0x9b,0x93,0x4c,0xa4,0x95,0x99,0x1b,0x78,0x52,0xb8,0x55};
  uint8_t sha384[] = {0x38,0xb0,0x60,0xa7,0x51,0xac,0x96,0x38,0x4c,0xd9,0x32,0x7e,0xb1,0xb1,0xe3,0x6a,0x21,0xfd,0xb7,0x11,0x14,0xbe,0x07,0x43,0x4c,0x0c,0xc7,0xbf,0x63,0xf6,0xe1,0xda,0x27,0x4e,0xde,0xbf,0xe7,0x6f,0x65,0xfb,0xd5,0x1a,0xd2,0xf1,0x48,0x98,0xb9,0x5b};
  uint8_t sha512[] = {0xcf,0x83,0xe1,0x35,0x7e,0xef,0xb8,0xbd,0xf1,0x54,0x28,0x50,0xd6,0x6d,0x80,0x07,0xd6,0x20,0xe4,0x05,0x0b,0x57,0x15,0xdc,0x83,0xf4,0xa9,0x21,0xd3,0x6c,0xe9,0xce,0x47,0xd0,0xd1,0x3c,0x5d,0x85,0xf2,0xb0,0xff,0x83,0x18,0xd2,0x87,0x7e,0xec,0x2f,0x63,0xb9,0x31,0xbd,0x47,0x41,0x7a,0x81,0xa5,0x38,0x32,0x7a,0xf9,0x27,0xda,0x3e};

  DataLen = 0;
  printf("Data   : ");
  print_hex(Data, DataLen, false);
  HashLen = digest_message(NULL, DataLen, Hash, EVP_sha224());
  EXPECT_EQ(HashLen, 224/8);
  EXPECT_ARRAY_EQ(Hash, sha224, HashLen);
  printf("Hash224: ");
  print_hex(Hash, HashLen, false);

  HashLen = digest_message(NULL, DataLen, Hash, EVP_sha256());
  EXPECT_EQ(HashLen, 256/8);
  EXPECT_ARRAY_EQ(Hash, sha256, HashLen);
  printf("Hash256: ");
  print_hex(Hash, HashLen, false);

  HashLen = digest_message(NULL, DataLen, Hash, EVP_sha384());
  EXPECT_EQ(HashLen, 384/8);
  EXPECT_ARRAY_EQ(Hash, sha384, HashLen);
  printf("Hash384: ");
  print_hex(Hash, HashLen, false);  

  HashLen = digest_message(NULL, DataLen, Hash, EVP_sha512());
  EXPECT_EQ(HashLen, 512/8);
  EXPECT_ARRAY_EQ(Hash, sha512, HashLen);
  printf("Hash512: ");
  print_hex(Hash, HashLen, false);
}

TEST_F(SHA2Test, 32ka)
{
  uint8_t sha224[] = {0xb6,0x5e,0x4a,0xf8,0x47,0x3e,0x3b,0xa3,0x70,0x6e,0xa8,0xe5,0x82,0xc0,0x71,0x73,0xd4,0x89,0x61,0xe7,0xae,0x9b,0xcb,0xa7,0x8c,0xed,0x78,0x4a};
  uint8_t sha256[] = {0xb0,0xa8,0x14,0xe1,0xbc,0x34,0xdb,0x5f,0x9d,0xb3,0x5c,0x59,0xba,0x38,0x01,0xd1,0xd4,0xeb,0x47,0x60,0x30,0xde,0x3c,0xc0,0x0a,0xf2,0xb2,0x83,0x2a,0x97,0x0b,0x4a};
  uint8_t sha384[] = {0x43,0x2c,0x7c,0x7c,0xef,0xaa,0xad,0x05,0xcb,0x13,0xbc,0xff,0x0a,0xa6,0xfe,0xf3,0xf8,0xed,0xc6,0xcc,0xc1,0xf1,0x8a,0x11,0x8e,0x8d,0x3e,0x65,0x4a,0x6d,0x29,0x0f,0xee,0x27,0x92,0x22,0x45,0xde,0xef,0x7e,0xc1,0xc1,0xa3,0xe8,0x26,0x82,0xe9,0xb9};
  uint8_t sha512[] = {0x8b,0x4d,0xa4,0xe8,0xd3,0xcf,0x31,0xef,0x24,0x01,0xd1,0x7d,0x01,0xf2,0x5d,0x53,0x16,0x06,0x21,0x43,0x3b,0x84,0x86,0xe6,0x64,0x4f,0xae,0x12,0x34,0x7c,0x75,0xd6,0xd6,0x4b,0x8a,0xea,0x4e,0x57,0x31,0x62,0x84,0xf7,0x62,0x7d,0x7d,0xde,0x36,0x44,0x89,0x38,0xf7,0x12,0x19,0x1f,0x3e,0xf7,0x31,0x3b,0x5c,0xd5,0x66,0xb9,0xac,0x50};

  DataLen = 32*1024;
  memset(Data+0*8*1024, 'A', 8*1024);
  memset(Data+1*8*1024, 'B', 8*1024);
  memset(Data+2*8*1024, 'C', 8*1024);
  memset(Data+3*8*1024, 'D', 8*1024);
  printf("Data   : 32ka\n");

  HashLen = digest_message(Data, DataLen, Hash, EVP_sha224());
  EXPECT_EQ(HashLen, 224/8);
  EXPECT_ARRAY_EQ(Hash, sha224, HashLen);
  printf("Hash224: ");
  print_hex(Hash, HashLen, false);

  HashLen = digest_message(Data, DataLen, Hash, EVP_sha256());
  EXPECT_EQ(HashLen, 256/8);
  EXPECT_ARRAY_EQ(Hash, sha256, HashLen);
  printf("Hash256: ");
  print_hex(Hash, HashLen, false);

  HashLen = digest_message(Data, DataLen, Hash, EVP_sha384());
  EXPECT_EQ(HashLen, 384/8);
  EXPECT_ARRAY_EQ(Hash, sha384, HashLen);
  printf("Hash384: ");
  print_hex(Hash, HashLen, false);  

  HashLen = digest_message(Data, DataLen, Hash, EVP_sha512());
  EXPECT_EQ(HashLen, 512/8);
  EXPECT_ARRAY_EQ(Hash, sha512, HashLen);
  printf("Hash512: ");
  print_hex(Hash, HashLen, false);
}



TEST_F(SHA2Test, ex)
{
  uint8_t sha256[] = {0xb0,0xa8,0x14,0xe1,0xbc,0x34,0xdb,0x5f,0x9d,0xb3,0x5c,0x59,0xba,0x38,0x01,0xd1,0xd4,0xeb,0x47,0x60,0x30,0xde,0x3c,0xc0,0x0a,0xf2,0xb2,0x83,0x2a,0x97,0x0b,0x4a};
  uint32_t temp_len = 0;
  uint8_t *p_Data = Data;

  DataLen = 32*1024;
  temp_len = DataLen;
  memset(Data+0*8*1024, 'A', 8*1024);
  memset(Data+1*8*1024, 'B', 8*1024);
  memset(Data+2*8*1024, 'C', 8*1024);
  memset(Data+3*8*1024, 'D', 8*1024);
  printf("Data   : 32kABCD\n");

  HashLen = digest_message(Data, DataLen, Hash, EVP_sha256());

  EVP_MD_CTX *mdctx;

  if((mdctx = EVP_MD_CTX_new()) == NULL)
    printf("EVP_MD_CTX_new Error");

  if(1 != EVP_DigestInit(mdctx, EVP_sha256()))
    printf("EVP_DigestInit Error");
  while(temp_len > 0)
  {
    if(temp_len > SegSize)
    {
      if(1 != EVP_DigestUpdate(mdctx, p_Data, SegSize))
        printf("EVP_DigestUpdate Error"); 
      p_Data += SegSize;
      temp_len -= SegSize;
    }
    else
    {
      if(1 != EVP_DigestUpdate(mdctx, p_Data, temp_len))
        printf("EVP_DigestUpdate Error"); 
      p_Data += temp_len;
      temp_len = 0;
    }
  }

  if(1 != EVP_DigestFinal(mdctx, Hash, &HashLen))
    printf("EVP_DigestFinal Error");

  EVP_MD_CTX_free(mdctx);

  EXPECT_EQ(HashLen, 256/8);
  EXPECT_ARRAY_EQ(Hash, sha256, HashLen);
  printf("Hash256: ");
  print_hex(Hash, HashLen, false);
}

TEST_F(SHA2Test, BreakUpdate)
{
  uint8_t sha256[] = {0xb0,0xa8,0x14,0xe1,0xbc,0x34,0xdb,0x5f,0x9d,0xb3,0x5c,0x59,0xba,0x38,0x01,0xd1,0xd4,0xeb,0x47,0x60,0x30,0xde,0x3c,0xc0,0x0a,0xf2,0xb2,0x83,0x2a,0x97,0x0b,0x4a};
  uint32_t temp_len = 0;
  uint8_t *p_Data = Data;
  uint8_t times = 0;

  DataLen = 32*1024;
  temp_len = DataLen;
  memset(Data+0*8*1024, 'A', 8*1024);
  memset(Data+1*8*1024, 'B', 8*1024);
  memset(Data+2*8*1024, 'C', 8*1024);
  memset(Data+3*8*1024, 'D', 8*1024);
  printf("Data   : 32kABCD\n");

  HashLen = digest_message(Data, DataLen, Hash, EVP_sha256());

  EVP_MD_CTX *mdctx;

  if((mdctx = EVP_MD_CTX_new()) == NULL)
    printf("EVP_MD_CTX_new Error");

  if(1 != EVP_DigestInit(mdctx, EVP_sha256()))
    printf("EVP_DigestInit Error");

  while(temp_len > 0)
  {
    if(times >= 2)
    {
      p_Data = Data;
      temp_len = DataLen;
      break;
    }
    if(temp_len > SegSize)
    {
      if(1 != EVP_DigestUpdate(mdctx, p_Data, SegSize))
        printf("EVP_DigestUpdate Error"); 
      p_Data += SegSize;
      temp_len -= SegSize;
    }
    else
    {
      if(1 != EVP_DigestUpdate(mdctx, p_Data, temp_len))
        printf("EVP_DigestUpdate Error"); 
      p_Data += temp_len;
      temp_len = 0;
    }
    times++;
  }

  while(temp_len > 0)
  {
    if(temp_len > SegSize)
    {
      if(1 != EVP_DigestUpdate(mdctx, p_Data, SegSize))
        printf("EVP_DigestUpdate Error"); 
      p_Data += SegSize;
      temp_len -= SegSize;
    }
    else
    {
      if(1 != EVP_DigestUpdate(mdctx, p_Data, temp_len))
        printf("EVP_DigestUpdate Error"); 
      p_Data += temp_len;
      temp_len = 0;
    }
  }

  if(1 != EVP_DigestFinal(mdctx, Hash, &HashLen))
    printf("EVP_DigestFinal Error");

  EVP_MD_CTX_free(mdctx);

  EXPECT_EQ(HashLen, 256/8);
  EXPECT_ARRAY_EQ(Hash, sha256, HashLen);
  printf("Hash256: ");
  print_hex(Hash, HashLen, false);
}

TEST_F(SHA2Test, BreakUpdateWithReset)
{
  uint8_t sha256[] = {0xb0,0xa8,0x14,0xe1,0xbc,0x34,0xdb,0x5f,0x9d,0xb3,0x5c,0x59,0xba,0x38,0x01,0xd1,0xd4,0xeb,0x47,0x60,0x30,0xde,0x3c,0xc0,0x0a,0xf2,0xb2,0x83,0x2a,0x97,0x0b,0x4a};
  uint32_t temp_len = 0;
  uint8_t *p_Data = Data;
  uint8_t times = 0;

  DataLen = 32*1024;
  temp_len = DataLen;
  memset(Data+0*8*1024, 'A', 8*1024);
  memset(Data+1*8*1024, 'B', 8*1024);
  memset(Data+2*8*1024, 'C', 8*1024);
  memset(Data+3*8*1024, 'D', 8*1024);
  printf("Data   : 32kABCD\n");

  HashLen = digest_message(Data, DataLen, Hash, EVP_sha256());

  EVP_MD_CTX *mdctx;

  if((mdctx = EVP_MD_CTX_new()) == NULL)
    printf("EVP_MD_CTX_new Error");

  if(1 != EVP_DigestInit(mdctx, EVP_sha256()))
    printf("EVP_DigestInit Error");

  while(temp_len > 0)
  {
    if(times >= 2)
    {
      p_Data = Data;
      temp_len = DataLen;
      break;
    }
    if(temp_len > SegSize)
    {
      if(1 != EVP_DigestUpdate(mdctx, p_Data, SegSize))
        printf("EVP_DigestUpdate Error"); 
      p_Data += SegSize;
      temp_len -= SegSize;
    }
    else
    {
      if(1 != EVP_DigestUpdate(mdctx, p_Data, temp_len))
        printf("EVP_DigestUpdate Error"); 
      p_Data += temp_len;
      temp_len = 0;
    }
    times++;
  }

  EVP_MD_CTX_reset(mdctx);

  while(temp_len > 0)
  {
    if(temp_len > SegSize)
    {
      if(1 != EVP_DigestUpdate(mdctx, p_Data, SegSize))
        printf("EVP_DigestUpdate Error"); 
      p_Data += SegSize;
      temp_len -= SegSize;
    }
    else
    {
      if(1 != EVP_DigestUpdate(mdctx, p_Data, temp_len))
        printf("EVP_DigestUpdate Error"); 
      p_Data += temp_len;
      temp_len = 0;
    }
  }
  
  if(1 != EVP_DigestFinal(mdctx, Hash, &HashLen))
    printf("EVP_DigestFinal Error");

  EVP_MD_CTX_free(mdctx);

  EXPECT_EQ(HashLen, 256/8);
  EXPECT_ARRAY_EQ(Hash, sha256, HashLen);
  printf("Hash256: ");
  print_hex(Hash, HashLen, false);
}